# Linux Kernel Vulnerabilities: State-of-the-Art Defenses and Open Problems

主要有两个结果
1. 分析 141 个 Linux CVE 之后, 将 CVE 分类分析
2. 针对已有研究者提出的方法, 研究这些方法有多有效

## 分析
分成 10 类.

1. 没有检查指针.
如 `__get_user`.

2. 没有检查权限.
执行特权操作, 但是没有检查 caller 进程的权限.

3. 缓冲溢出.
各种.

4. 整数溢出.
e.g. 分配 `a-b` 大小的内存.

5. 未初始化数据.
复制内核缓冲区到用户程序, 但是没有清空, 造成信息泄漏.

6. 空指针解引用.

7. 除以 0.

8. 死循环.

9. 竞争 / 死锁.

10. 内存管理出错.
内存泄漏, double free, use-after-free.

最主要的是 缓冲整数溢出.
有 1/3 的 CVE 在内核 core 而非内核模块中.

## 现有防御方法
* 软件故障隔离: BGI 隔离内核模块.
不能处理内核 core 的问题.

* 代码完整性: hypervisor 在执行代码段之前检查其未被破坏.
不能完全解决问题.

* 用户态驱动: SUD. 很有用, 但是 `driver/` 只占 CVE 的 20%.

* 内存标签 memory tagging.

* 追踪未初始化内存: Kmemcheck.
不能防止从栈上读到未定义的数据.

* 静态分析: 高 false-positive.
难以分析和语义相关的问题, 如缺失权限检查.

总结地说, 现有的防御方法都针对某一种问题而非所有的.
并且很多弱点都是因为 Linux 是用 C 写的.
